% \VignetteIndexEntry{RJaCGH Overview}
% \VignetteDepends{RJaCGH}
% \VignetteKeywords{RJMCMC CGH Analysis}
% \VignettePackage{RJaCGH}

\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\title{RJaCGH: A package for the analysis of CGH arrays through Reversible Jump MCMC.}
\author{Oscar M. Rueda$^{1}$ and Ram\'on D\'{\i}az-Uriarte$^{1}$}
\begin{document}
\maketitle

\begin{center}
1. Statistical Computing Team. Spanish National Cancer Center (CNIO), Madrid
(SPAIN).
{\tt omrueda@cnio.es}, {\tt rdiaz@ligarto.org}
\end{center}

\tableofcontents

\section{Overview:}
RJaCGH is an R package designed for the analysis of CGH data.
Basically, it fits a Non Homogeneous Hidden Markov Model through Reversible Jump
Markov Chain Montecarlo.
The package estimates the probability for every gene to have a normal copy number, 
gained or lost.
The technical report gives full details about the statistical model and the 
parameterization it uses, plus algorithm details.

Please note that our methods are computer intensive, so they may take a long
time on a slow machine.
\section{Data:}

We use for the examples the public data set of Snijders et al. (10001) with 15 human cells
with known karyotypes. We use here the objects in package GLAD 1.6.0. (Hupp\'e and Barillot).

\section{Examples:}

\subsection{Same model for the whole genome}
We'll analyze data cell gm13330 from Snijders. First, we take out the missing
values, because RJaCGH does not handle NA's:

<<>>=
set.seed(1)
library(RJaCGH)
data(snijders)
y <- gm13330$LogRatio[!is.na(gm13330$LogRatio)]
Pos <- gm13330$PosBase[!is.na(gm13330$LogRatio)]
Chrom <- gm13330$Chromosome[!is.na(gm13330$LogRatio)]

@ 

We can fit  the same Non Homogeneous Hidden Markov Model to the whole 
genome with the function \texttt{RJaCGH}, setting the \texttt{model} 
argument to 'genome'.
We will fit HMM's with a maximum of four hidden states,  so we'll 
set the parameter \texttt{k.max=4}.\\
We can also set, if we wish to, the jumping parameters of the MCMC. There are two types:
\begin{itemize}
\item{The standard deviation of the candidates of the jumps of the
chain within a given model: \texttt{sigma.tau.mu}, 
\texttt{sigma.tau.sigma.2} and 
\texttt{sigma.tau.beta}. They are vectors of length \texttt{k.max}. They 
are related to the dispersion within models.}
\item{The standard deviation of the jumps between models in split/combine
moves: \texttt{tau.split.mu} and \texttt{tau.split.beta}. They are scalars and
are related to the dispersion between models.}
\end{itemize}
We must remember that these are not parameters of the model, in the sense 
that different values produce different models. They are parameters of the 
algorithm that speed up or assure convergence.

We have to enclose them in a list. By some inspection of the data and/or
trial/error we set them to the following values:

<<>>=
jump.parameters <- list(sigma.tau.mu=rep(0.01, 4), 
		sigma.tau.sigma.2=rep(0.05, 4),
		sigma.tau.beta=rep(0.1, 4), 
		tau.split.mu=0.1, tau.split.beta=0.1)

fit  <- RJaCGH(y=y, Pos=Pos, Chrom=Chrom, model="genome", 
k.max=4, burnin=50000, TOT=10000, jump.parameters=jump.parameters, auto.label=0.75)

@ 

The parameter \texttt{auto.label} is optional and represents the expected
minimum proportion of normal genes in the sample. It can be set to NULL if it is
unknown, but here we will set it to 0.75.

After the fit (it may take a little while),  we can inspect the posterior 
probability of the number of hidden states
(different number of copy numbers):

<<>>=
round(prop.table(table(fit$k)), 3)

@ 


The fit object is a list with several lists nested; one for each model fitted.
For example, 

<<results=hide>>=
fit[[4]]
@ 

is a list with the results of the fit of a model with 4 hidden states.
There are several elements inside; for example, we can access to the 
means and variances of the hidden states fitted:

<<results=hide>>=
fit[[4]]$mu
fit[[4]]$sigma.2
@ 

They are matrices with as many rows as samples have been drawn to a model with 4
hidden states and as many columns as hidden states (that is, four).

<<>>=
apply(fit[[4]]$mu, 2, mean)
@ 

would be the mean of the posterior distribution of the means of the
4 hidden states.

In the case of the function of transition probabilities:

<<results=hide>>=
fit[[4]]$beta
@ 

is an array with the first and second dimensions the number of hidden states
and the third the number of MCMC iterations in that model. So

<<>>=
apply(fit[[4]]$beta, c(1, 2), mean)
@ 

would give the mean of the posterior distribution of \texttt{beta}
(the transition matrix depends on the distance between genes; see 
tech. report for details on the model).
We can also summarize the fit and inspect these results. By default, 
\texttt{summary} returns the median of the posterior distributions:

<<>>=

summary.HMM <- summary(fit)
summary.HMM$mu
summary.HMM$sigma.2

@ 

We can also plot the model and the classification of genes to the hidden states:

\begin{center}
 \setkeys{Gin}{height=16cm}
 \setkeys{Gin}{width=14cm}

<<fig=TRUE>>=
plot(fit, cex=1.1)

@ 

\end{center}
The color 'green' correspond to states of loss, the 'black' to normal
states and the 'red' to gains.
Note that two states have been labeled as 'Normal'. As statistical
states do not always correspond to biological states, RJaCGH does an
automatic labeling based on the posterior means and variances of the
hidden states and the argument \texttt{auto.label} (see the help file
for \texttt{RJaCGH} for details).
If the user wants to make his own relabelling of states, he has to define
\texttt{fit[[k]]\$state.labels}, for the model \texttt{k} of interest. It
must be a vector of length \texttt{k} with elements 'Loss', 'Normal' or
'Gain'. For example, in our case:
<<>>=
  fit[[4]]$state.labels <- c("Loss", rep("Normal", 2), "Gain")
@ 

There are other methods to extract more information,  as \texttt{states} or 
\texttt{model.averaging}. They will be introduced in the next section.

We can also inspect the convergence of the most visited model:

\begin{center}

<<fig=TRUE>>=
trace.plot(fit)
@ 

\end{center}
If we don't see good mixing we can re-adjust the jumping parameters:
\begin{itemize}
\item{If the lines are too straight for some parameters, 
we must reduce its corresponding jumping parameters and refit.}
\item{If the lines oscilate too much, we should refit with greater 
jumping parameters.}
\item{The parameters that rule the number of states mixing are 
\texttt{tau.split.mu} and \texttt{tau.split.beta}, and the parameters
that rule the means, the variances and \texttt{beta} are 
\texttt{sigma.tau.mu},\texttt{sigma.tau.sigma.2} and \texttt{sigma.tau.beta}.}
\end{itemize}
We can also check the proportion of different values in the chain: it should be
around 0.23. We'll do it for the model with highest posterior probability:

<<>>=
maxK <- as.numeric(names(which.max(table(fit$k))))
fit[[maxK]]$prob.mu
fit[[maxK]]$prob.sigma.2
fit[[maxK]]$prob.beta

@ 

And finally, We can check that the algorithm has made some jumps between models 
(birth, death, split and combine movements):

<<>>=
fit$prob.b
fit$prob.d
fit$prob.s
fit$prob.c

@ 

These numbers include the
the burn-in iterations. \\



\subsection{A different model for every chromosome}
We can also fit a different model for every chromosome 
with the function \texttt{RJaCGH} changing the parameter
\texttt{model} to 'Chrom'.
We recommend fitting by chromosome only when the data are normalized in every
chromosome, because otherwise we couldn't detect a whole chromosome 
gained/lost. We'll fit a model to other cell line: 01524.
Every chromosome should have its own set of jumping parameters, so we won't 
specify them and let RJaCGH do a simple search to find 'good' ones:

<<echo=TRUE, results=hide>>=
y2 <- gm01524$LogRatio[!is.na(gm01524$LogRatio)]
Pos2 <- gm01524$PosBase[!is.na(gm01524$LogRatio)]
Chrom2 <- gm01524$Chromosome[!is.na(gm01524$LogRatio)]
fit.chrom  <- RJaCGH(y=y2, Pos=Pos2, Chrom=Chrom2, model="Chrom", 
k.max=4, burnin=50000, TOT=10000)

@ 

We can access the results for every chromosome in a simple way, because
the objects now contains every list for every chromosome, and
every chromosome inlcudes a list of the same kind as explained in 
the former secton. For example, to inspect the chromosome 6:
<<>>=

summary.chrom.6 <- summary(fit.chrom[[6]])
summary.chrom.6$mu
summary.chrom.6$sigma.2

@ 

We can also see the sequence of hidden states, that is the copy number 
status for every gene. We can compute it conditionally to the most visited 
model, (with the method \texttt{states}) or averaging through every model
 fit weighted by the posterior probability of that model 
(method \texttt{model.averaging}):

<<>>=
sequence <- states(fit.chrom)
sequence.averaged <- model.averaging(fit.chrom)
@ 
We can see the copy number of chromosome 6:
<<>>=
head(sequence[[6]]$states)
head(sequence.averaged[[6]]$states)
@ 
And the probability of every state in that chromosome:
<<>>=
head(sequence[[6]]$prob.states)
head(sequence.averaged[[6]]$prob.states)
@ 

These methods can be also used on a fit with the same model on the whole genome,
as the one in the last section.

We can also plot the whole genome or just a chromosome:

\begin{center}
\setkeys{Gin}{height=8cm}
\setkeys{Gin}{width=12cm}

<<fig=TRUE>>=
plot(fit.chrom)

@ 
\setkeys{Gin}{height=16cm}
\setkeys{Gin}{width=14cm}


<<fig=TRUE>>=
plot(fit.chrom[[6]])

@ 

\end{center}

Finally, we can also see the probabilities of alteration in 
a graph chromosome by chromosome:


<<results=hide>>=
genome.plot(fit.chrom)
@ 
\begin{center}
\setkeys{Gin}{width=14cm}
\setkeys{Gin}{width=14cm}

<<results=tex,echo=FALSE>>=
file="genome.pdf"
pdf(file=file, width=12)
genome.plot(fit.chrom)
dev.off() 
cat("\\includegraphics{", file, "}\n\n", sep="")

@ 
\end{center}

\subsection{Fitting several arrays}

We can also fit at the same time several arrays (if they have the same
genes spotted in the same positions), but RJaCGH fits a different model
to each of them:

<<>>=

gm07081LR <- gm07081$LogRatio
gm10315LR <- gm10315$LogRatio
not.NA <- !is.na(gm07081LR) & !is.na(gm10315LR)
gm07081LR <- gm07081LR[not.NA]
gm10315LR <- gm10315LR[not.NA]
Pos3 <- gm07081$PosBase[not.NA]
Chrom3 <- gm07081$Chromosome[not.NA]

fit.arrays  <- RJaCGH(y=cbind(gm07081LR, gm10315LR), 
Pos=Pos3, Chrom=Chrom3,
 model="genome", k.max=4, burnin=50000, TOT=10000, auto.label=0.75)

@ 

We can examine every one of them the same way, but now the object is a
list whose elements are every array fitted:

<<>>=

summary(fit.arrays[['gm07081LR']])$mu
summary(fit.arrays[['gm10315LR']])$mu
@ 

And we can plot the copy number of every gene in several ways:
\begin{itemize}
\item{Averaging the probability of every gene for every array 
(by default with the same weight, but there
is a \texttt{weights} argument to include reliability or importance of
each array).}
\item{Plotting the percentage of arrays in which every gene is 
(marginally) gained or 
lost.}
\end{itemize}
\begin{center}

\setkeys{Gin}{height=8cm}
\setkeys{Gin}{width=12cm}

<<fig=TRUE>>=
plot(fit.arrays, method="averaging")

@ 

\setkeys{Gin}{height=8cm}
\setkeys{Gin}{width=12cm}

<<fig=TRUE>>=
plot(fit.arrays, method="region")

@ 
\end{center}


We can also compare the classification of genes with the true states of 
Snijders:

<<>>=

seq.states <- model.averaging(fit.arrays[['gm07081LR']])$states
table(seq.states, gm07081$Statut[not.NA])

@ 

\subsection{Probabilistic Minimal Common Regions}

RJaCGH can also compute probabilistic minimal common regions. Note that
these regions are different to other MCR approaches, because they don't
take into account the precision or variability inherent to the estimation
of the true copy number for every gene on every array considered.
\texttt{pMCR} computes all the region of genes 
with a probability of alteration as high as a given threshold.\\
For a single array, they are interesting because the genes are not
independent, so the probability for any sequence is not the product of
its marginal probabilities. For several arrays, \texttt{pMCR} averages
the joint probability of every array as if they were independent and
identically distributed sequences.
For example, 

<<>>=

pMCR(fit, p=0.9, alteration="Gain")
pMCR(fit, p=0.9, alteration="Loss")

@ 
would give us regions for gains and losses of at least 0.9 probability.
Note also that the threshold is for each region, not for all of them; this
means that the probability of all regions doesn't have to be over 0.9.
\\

For the two arrays analyzed:

<<>>=

pMCR(fit.arrays, p=0.5, alteration="Gain")
pMCR(fit.arrays, p=0.5, alteration="Loss")

@ 


\subsection{Checking convergence}

We have seen the function \texttt{trace.plot} to check convergence in a 
given model. But the best way to be sure that RJaCGH has converged 
is to run several parallel chains and draw  Gelman-Brooks convergence plot. 
In this example, We use data from cell line gm01524, but only from 
chromosome 1 to save time:

\begin{center}

<<fig=TRUE, results=hide>>=

fit <- list()

for(i in 1:4) {
      fit[[i]] <- RJaCGH(y=y2[Chrom2==1], Pos=Pos2[Chrom2==1], 
      k.max=4, burnin=30000, TOT=10000, jump.parameters=jump.parameters,
      auto.label=0.75)
}
gelman.brooks.plot(fit)
@ 
\end{center}
We should check that the lines converge to zero, or at least that remain
under 1.1. The values that return the function should be under 1.1, too.
The results are satisfactory, so we can join the four chains into one:
<<>>=

fit <- collapseChain(fit)
@

And use the former methods to the object \texttt{fit}.

Other useful function is \texttt{selectChains}, which deletes 'outliers'
chains. See help file for details.


\begin{thebibliography}{1}

\bibitem{B}Brooks, S.P. and Gelman, A. (1998). 
{\em "General Methods for
  Monitoring convergence of iterative simulations"}. 
Journal of Computational and Graphical Statistics. p434-455.


\bibitem{C}Capp\'e, Moulines and Ryd\'en. (2005)
{\em "Inference in Hidden Markov Models"}.
Springer.

\bibitem{G}Green, P.J. (1995) 
{\em "Reversible Jump Markov Chain Monte Carlo
computation and Bayesian model determination"}. 
Biometrika, 82, 711-732.

\bibitem{R]}Rueda, O.M. and D\'iaz-Uriarte, R. (2006)
{\em "A flexible, accurate and extensible statistical 
method for detecting genomic copy-number changes}, In prep.

\bibitem{S}Snijders, M. J. et al. (2001)
{\em "Assembly of microarrays for genome-wide measurement of
    DNA copy number"}.
    Nature Genetics 29, pp 263 - 264.
\bibitem{H}Hupp\'e, P. (2005). 
{\em "GLAD: Gain and Loss Analysis of DNA"}.
    R package version 1.6.0. http://bioinfo.curie.fr

\end{thebibliography}
\end{document}
